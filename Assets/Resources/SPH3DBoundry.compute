   
   
#include "utils/structures.cginc"
#include "utils/buffers.cginc"
#include "utils/constants.cginc"

#include "collison_detection/normalWallBoundray.cginc"

#pragma kernel DensityCS
#pragma kernel PressureCS
#pragma kernel ForceCS
#pragma kernel IntegrateCS

// Keep the number of threads one-dimensional for simplicity
#define THREAD_SIZE_X 1024

// ▼ ★ Main body from here --------------------------------------

#include "kernels/Densitykernel.cginc"
#include "kernels/pressurekernel.cginc"
#include "kernels/gradPressurekernel.cginc"
#include "kernels/viscositykernel.cginc"
#include "kernels/surfaceTensionkernel.cginc"


// ▼ Kernel function

//--------------------------------------------------------------------------------------
// Density calculation
//--------------------------------------------------------------------------------------
[numthreads(THREAD_SIZE_X, 1, 1)]
void DensityCS(uint3 DTid : SV_DispatchThreadID) {
	uint P_ID = DTid.x;	// Particle ID currently being processed

	float h_sq = _Smoothlen * _Smoothlen;
	float3 P_position = _ParticlesBufferRead[P_ID].position;

	// TODO:convert To hash
	// Neighborhood search(O(n^2))
	float density = 0;
	for (uint N_ID = 0; N_ID < (uint)_NumParticles; N_ID++) {
		if (N_ID == P_ID) continue;	// Skip if self is the calculation target

		float3 N_position = _ParticlesBufferRead[N_ID].position;
		// N=j
		// P=i
		float3 diff = N_position - P_position;	// Particle distance
		float r_sq = dot(diff, diff);			// Particle distance squared

		// Exclude particles that do not fit within the radius
		if (r_sq < h_sq) {
			density += CalculateDensity(r_sq);	// No need to take the route
		}
	}

	// Update density buffer
	_ParticlesDensityBufferWrite[P_ID].density = density;
}


//--------------------------------------------------------------------------------------
// Pressure calculation ///  equation Tait
//--------------------------------------------------------------------------------------
[numthreads(THREAD_SIZE_X, 1, 1)]
void PressureCS(uint3 DTid : SV_DispatchThreadID) {
	uint P_ID = DTid.x;	// Particle ID currently being processed

	float  P_density = _ParticlesDensityBufferRead[P_ID].density;	// Density calculated earlier
	float  P_pressure = CalculatePressure(P_density);	// Pressure calculation

	// Update pressure buffer
	_ParticlesPressureBufferWrite[P_ID].pressure = P_pressure;
}


//--------------------------------------------------------------------------------------
// Calculation of force (acceleration)
//--------------------------------------------------------------------------------------
[numthreads(THREAD_SIZE_X, 1, 1)]
void ForceCS(uint3 DTid : SV_DispatchThreadID) {
	uint P_ID = DTid.x; // Particle ID currently being processed

	float3 P_position = _ParticlesBufferRead[P_ID].position;
	float3 P_velocity = _ParticlesBufferRead[P_ID].velocity;
	float  P_density = _ParticlesDensityBufferRead[P_ID].density;		// Density calculated earlier
	float  P_pressure = _ParticlesPressureBufferRead[P_ID].pressure;	// The pressure calculated earlier

	const float h_sq = _Smoothlen * _Smoothlen;
	//N=j
	//P=i
	// Neighborhood search(O(n^2))
	float3 press = float3(0, 0, 0);
	float3 visco = float3(0, 0, 0);
	// float3 surfaceTension = float3(0, 0, 0);
	ColorField temp;
	ColorField color;
	for (uint N_ID = 0; N_ID < (uint)_NumParticles; N_ID++) {
		if (N_ID == P_ID) continue;	// Skip if targeting yourself

		float3 N_position = _ParticlesBufferRead[N_ID].position;

		float3 diff = N_position - P_position;
		float r_sq = dot(diff, diff);

		// Exclude particles that do not fit within the radius
		if (r_sq < h_sq) {	
			float  N_density = _ParticlesDensityBufferRead[N_ID].density;
			float  N_pressure = _ParticlesPressureBufferRead[N_ID].pressure;
			float3 N_velocity = _ParticlesBufferRead[N_ID].velocity;
			float  r = sqrt(r_sq);

			// Pressure term
			press += CalculateGradPressure(r, P_pressure, N_pressure, N_density, diff);

			// sticky item
			visco += CalculateLapVelocity(r, P_velocity, N_velocity, N_density);

			temp=CalculateSurfaceTension(r_sq,N_density,diff);
			color.colorGradient+=temp.colorGradient;
			color.colorLaplacian+=temp.colorLaplacian;


		}
	}
	float3 colorGradient=color.colorGradient;
	float madntiude=sqrt(colorGradient.x*colorGradient.x + colorGradient.y*colorGradient.y + colorGradient.z*colorGradient.z);
	float3 tension=-_tensionCoefficient*color.colorLaplacian*color.colorGradient/madntiude;
	tension=float3(0,0,0);
	
	// Integration
	float3 force = press + _Viscosity * visco + tension;

	// Acceleration buffer update
	_ParticlesForceBufferWrite[P_ID].acceleration = force / P_density;
}


//--------------------------------------------------------------------------------------
// Update the position by performing collision detection etc.
//--------------------------------------------------------------------------------------
[numthreads(THREAD_SIZE_X, 1, 1)]
void IntegrateCS(uint3 DTid : SV_DispatchThreadID) {
	const unsigned int P_ID = DTid.x; // Particle ID currently being processed

	// Position and speed before update
	float3 position = _ParticlesBufferRead[P_ID].position;
	float3 velocity = _ParticlesBufferRead[P_ID].velocity;
	float3 acceleration = _ParticlesForceBufferRead[P_ID].acceleration;	// Calculated acceleration

	// if (distance(position, _MousePos.xy) < _MouseRadius && _MouseDown) {
	// 	float3 dir = position - _MousePos.xy;
	// 	float pushBack = _MouseRadius-length(dir);
	// 	acceleration += 100 * pushBack * normalize(dir);
	// }
    

	// Here to write collision detection -----

	// Wall boundary
	normalWallboundray(velocity,position);

	// Gravity addition
	//TODO:must _Gravity*_mass
	acceleration += _Gravity;

	// Update the next particle position with the forward Euler method
	velocity += _TimeStep * acceleration;
	position += _TimeStep * velocity;

	// Particle buffer update
	_ParticlesBufferWrite[P_ID].position = position;
	_ParticlesBufferWrite[P_ID].velocity = velocity;
}



