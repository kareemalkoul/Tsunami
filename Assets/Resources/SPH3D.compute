#pragma kernel DensityCS
#pragma kernel PressureCS
#pragma kernel ForceCS
#pragma kernel IntegrateCS

// Keep the number of threads one-dimensional for simplicity
#define THREAD_SIZE_X 1024

// ▼ Structured buffer definition ---------------------
struct Particle {
	float3 position;
	float3 velocity;
};

struct ParticlePressure {
	float pressure;
};

struct ParticleForces {
	float3 acceleration;
};

struct ParticleDensity {
	float density;
};

RWStructuredBuffer<float>			_DebugBuffer;

// Buffer to hold particle position and velocity
StructuredBuffer  <Particle>        _ParticlesBufferRead;
RWStructuredBuffer<Particle>        _ParticlesBufferWrite;

// Buffer to hold particle density
StructuredBuffer  <ParticleDensity> _ParticlesDensityBufferRead;
RWStructuredBuffer<ParticleDensity> _ParticlesDensityBufferWrite;

// Buffer to hold particle pressure
StructuredBuffer<ParticlePressure>	_ParticlesPressureBufferRead;
RWStructuredBuffer<ParticlePressure> _ParticlesPressureBufferWrite;

// Buffer that holds particle acceleration (force)
StructuredBuffer  <ParticleForces>  _ParticlesForceBufferRead;
RWStructuredBuffer<ParticleForces>  _ParticlesForceBufferWrite;
// ▲ Structured buffer definition ---------------------

// ▼ Definition of shader constants -----------------------
cbuffer CB {
	int   _NumParticles;		// Number of particles
	float _TimeStep;			// Time step width (dt)
	float _Smoothlen;			// Particle radius
	float _PressureStiffness;	// Becker's coefficient
	float _RestDensity;			// resting density
	float _DensityCoef;			// Coefficient when calculating density
	float _GradPressureCoef;	// Coefficient when calculating pressure
	float _LapViscosityCoef;	// Coefficient when calculating viscosity
	float _WallStiffness;		// The pushing force of the penalty method
	float _Viscosity;			// Viscosity coefficient
	float3 _Gravity;			// gravity
	float3 _Range;				// Simulation space

	//float3 _MousePos;			// マウス位置
	//float _MouseRadius;			// マウスインタラクションの半径
	//bool _MouseDown;			// マウスが押されているか
};
// ▲ Definition of shader constants -----------------------



// ▼ ★ Main body from here --------------------------------------

/// Implementation of Poly6 Kernel 
/// http://www.slis.tsukuba.ac.jp/~fujisawa.makoto.fu/cgi-bin/wiki/index.php?SPH%CB%A1%A4%CE%BD%C5%A4%DF%B4%D8%BF%F4
/// W_poly6(r, h) = DensityCoef * (h^2 - r^2)^3
/// -> DensityCoef = ParticleMass * 4 / (PI * Smoothlen^8)
inline float CalculateDensity(float r_sq) {
	const float h_sq = _Smoothlen * _Smoothlen;
	return _DensityCoef * (h_sq - r_sq) * (h_sq - r_sq) * (h_sq - r_sq);
}

/// Becker2007 Implementation of uncompressed conditions:
/// Pressure = B * ((rho / rho_0)^gamma  - 1)
/// The pressure constant B should be calculated accurately, but it is not suitable for real time, so set it to an appropriate value.
inline float CalculatePressure(float density) {
	return _PressureStiffness * max(pow(abs(density / _RestDensity), 7) - 1, 0);
}

/// Implementation of Spiky kernel
/// mass * ((pressure_i- pressure_j)/(2 * density_j)) * Grad(W_Spiky)
/// Grad(W_Spiky) = -30 / (pi * h^5) * (h - r)^2
inline float3 CalculateGradPressure(float r, float P_pressure, float N_pressure, float N_density, float3 diff) {
	const float h = _Smoothlen;
	float avg_pressure = 0.5f * (N_pressure + P_pressure);
	// _GradPressureCoef = particleMass * -45.0f / (Mathf.PI * Mathf.Pow(smoothlen, 6))
	// N=j
	// P=i curr particle
	// float3 Grad=W_Spiky=_GradPressureCoef*(h - r) * (h - r) * diff / r;
	return _GradPressureCoef * avg_pressure / N_density * (h - r) * (h - r) / r * (diff);
}

/// Viscosity kernel implementation:
/// mass * (u_j - u_i) / density_j * Laplacian(W_viscosity)
/// Laplacian(W_viscosity) = 20 / (3 * pi * h^5) * (h - r)
inline float3 CalculateLapVelocity(float r, float3 P_velocity, float3 N_velocity, float N_density) {
	const float h = _Smoothlen;
	// _LapViscosityCoef= particleMass * 45f / (Mathf.PI * Mathf.Pow(smoothlen, 6))
	// N=j
	// P=i curr particle
	float3 vel_diff = (N_velocity - P_velocity);
	return _LapViscosityCoef / N_density * (h - r) * vel_diff;
}



// ▼ Kernel function

//--------------------------------------------------------------------------------------
// Density calculation
//--------------------------------------------------------------------------------------
[numthreads(THREAD_SIZE_X, 1, 1)]
void DensityCS(uint3 DTid : SV_DispatchThreadID) {
	uint P_ID = DTid.x;	// Particle ID currently being processed

	float h_sq = _Smoothlen * _Smoothlen;
	float3 P_position = _ParticlesBufferRead[P_ID].position;

	// TODO:convert To hash
	// Neighborhood search(O(n^2))
	float density = 0;
	for (uint N_ID = 0; N_ID < (uint)_NumParticles; N_ID++) {
		if (N_ID == P_ID) continue;	// Skip if self is the calculation target

		float3 N_position = _ParticlesBufferRead[N_ID].position;
		// N=j
		// P=i
		float3 diff = N_position - P_position;	// Particle distance
		float r_sq = dot(diff, diff);			// Particle distance squared

		// Exclude particles that do not fit within the radius
		if (r_sq < h_sq) {
			density += CalculateDensity(r_sq);	// No need to take the route
		}
	}

	// Update density buffer
	_ParticlesDensityBufferWrite[P_ID].density = density;
}


//--------------------------------------------------------------------------------------
// Pressure calculation ///  equation Tait
//--------------------------------------------------------------------------------------
[numthreads(THREAD_SIZE_X, 1, 1)]
void PressureCS(uint3 DTid : SV_DispatchThreadID) {
	uint P_ID = DTid.x;	// Particle ID currently being processed

	float  P_density = _ParticlesDensityBufferRead[P_ID].density;	// Density calculated earlier
	float  P_pressure = CalculatePressure(P_density);	// Pressure calculation

	// Update pressure buffer
	_ParticlesPressureBufferWrite[P_ID].pressure = P_pressure;
}


//--------------------------------------------------------------------------------------
// Calculation of force (acceleration)
//--------------------------------------------------------------------------------------
[numthreads(THREAD_SIZE_X, 1, 1)]
void ForceCS(uint3 DTid : SV_DispatchThreadID) {
	uint P_ID = DTid.x; // Particle ID currently being processed

	float3 P_position = _ParticlesBufferRead[P_ID].position;
	float3 P_velocity = _ParticlesBufferRead[P_ID].velocity;
	float  P_density = _ParticlesDensityBufferRead[P_ID].density;		// Density calculated earlier
	float  P_pressure = _ParticlesPressureBufferRead[P_ID].pressure;	// The pressure calculated earlier

	const float h_sq = _Smoothlen * _Smoothlen;
	//N=j
	//P=i
	// Neighborhood search(O(n^2))
	float3 press = float3(0, 0, 0);
	float3 visco = float3(0, 0, 0);
	for (uint N_ID = 0; N_ID < (uint)_NumParticles; N_ID++) {
		if (N_ID == P_ID) continue;	// Skip if targeting yourself

		float3 N_position = _ParticlesBufferRead[N_ID].position;

		float3 diff = N_position - P_position;
		float r_sq = dot(diff, diff);

		// Exclude particles that do not fit within the radius
		if (r_sq < h_sq) {	
			float  N_density = _ParticlesDensityBufferRead[N_ID].density;
			float  N_pressure = _ParticlesPressureBufferRead[N_ID].pressure;
			float3 N_velocity = _ParticlesBufferRead[N_ID].velocity;
			float  r = sqrt(r_sq);

			// Pressure term
			press += CalculateGradPressure(r, P_pressure, N_pressure, N_density, diff);

			// sticky item
			visco += CalculateLapVelocity(r, P_velocity, N_velocity, N_density);
		}
	}

	// Integration
	float3 force = press + _Viscosity * visco;

	// Acceleration buffer update
	_ParticlesForceBufferWrite[P_ID].acceleration = force / P_density;
}


//--------------------------------------------------------------------------------------
// Update the position by performing collision detection etc.
//--------------------------------------------------------------------------------------
[numthreads(THREAD_SIZE_X, 1, 1)]
void IntegrateCS(uint3 DTid : SV_DispatchThreadID) {
	const unsigned int P_ID = DTid.x; // Particle ID currently being processed

	// Position and speed before update
	float3 position = _ParticlesBufferRead[P_ID].position;
	float3 velocity = _ParticlesBufferRead[P_ID].velocity;
	float3 acceleration = _ParticlesForceBufferRead[P_ID].acceleration;	// Calculated acceleration

	// Here to write collision detection -----

	// Wall boundary (penalty method)
	float dist;
	//x in 0
	dist = dot(float4(position, 1), float4(1, 0, 0, 0));
	acceleration += min(dist, 0) * -_WallStiffness * float3(1, 0, 0);
	//y in 0
	dist = dot(float4(position, 1), float4(0, 1, 0, 0));
	acceleration += min(dist, 0) * -_WallStiffness * float3(0, 1, 0);
	//z in 0
	dist = dot(float4(position, 1), float4(0, 0, 1, 0));
	acceleration += min(dist, 0) * -_WallStiffness * float3(0, 0, 1);
	//x in max
	dist = dot(float4(position, 1), float4(-1, 0, 0, _Range.x));
	acceleration += min(dist, 0) * -_WallStiffness * float3(-1, 0, 0);
	//y in max
	dist = dot(float4(position, 1), float4(0, -1, 0, _Range.y));
	acceleration += min(dist, 0) * -_WallStiffness * float3(0, -1, 0);
	//z in max
	dist = dot(float4(position, 1), float4(0, 0, -1, _Range.z));
	acceleration += min(dist, 0) * -_WallStiffness * float3(0, 0, -1);

	// Gravity addition
	//TODO:must _Gravity*_mass
	acceleration += _Gravity;

	// Update the next particle position with the forward Euler method
	velocity += _TimeStep * acceleration;
	position += _TimeStep * velocity;

	// Particle buffer update
	_ParticlesBufferWrite[P_ID].position = position;
	_ParticlesBufferWrite[P_ID].velocity = velocity;
}