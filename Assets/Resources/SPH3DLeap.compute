#pragma kernel DensityCS
#pragma kernel PressureCS
#pragma kernel ForceCS
#pragma kernel IntegrateCS

// Keep the number of threads one-dimensional for simplicity
#define THREAD_SIZE_X 1024

// ▼ Structured buffer definition ---------------------
struct Particle {
	float3 position;
	float3 velocity;
};

struct ParticlePressure {
	float pressure;
};

struct ParticleForces {
	float3 acceleration;
};

struct ParticleForcesOld {
	float3 acceleration;
};

struct ParticleDensity {
	float density;
};

struct ColorField {
	float colorField;
	float colorLaplacian;
	float3 colorGradient;
};

RWStructuredBuffer<float>			_DebugBuffer;

// Buffer to hold particle position and velocity
StructuredBuffer  <Particle>        _ParticlesBufferRead;
RWStructuredBuffer<Particle>        _ParticlesBufferWrite;

// Buffer to hold particle density
StructuredBuffer  <ParticleDensity> _ParticlesDensityBufferRead;
RWStructuredBuffer<ParticleDensity> _ParticlesDensityBufferWrite;

// Buffer to hold particle pressure
StructuredBuffer<ParticlePressure>	_ParticlesPressureBufferRead;
RWStructuredBuffer<ParticlePressure> _ParticlesPressureBufferWrite;

// Buffer that holds particle acceleration (force)
StructuredBuffer  <ParticleForces>  _ParticlesForceBufferRead;
RWStructuredBuffer<ParticleForces>  _ParticlesForceBufferWrite;

// Buffer that holds particle old acceleration (force)
StructuredBuffer  <ParticleForcesOld>  _ParticlesForceOldBufferRead;
RWStructuredBuffer<ParticleForcesOld>  _ParticlesForceOldBufferWrite;

// ▲ Structured buffer definition ---------------------

// ▼ Definition of shader constants -----------------------
cbuffer CB {
	int   _NumParticles;		// Number of particles
	float _TimeStep;			// Time step width (dt)
	float _Smoothlen;			// Particle radius
	float _PressureStiffness;	// Becker's coefficient

	float _RestDensity;			// resting density
	float _DensityCoef;			// Coefficient when calculating density
	float _GradPressureCoef;	// Coefficient when calculating pressure
	float _LapViscosityCoef;	// Coefficient when calculating viscosity

	float _WallStiffness;		// The pushing force of the penalty method
	float _Viscosity;			// Viscosity coefficient
	float3 _Gravity;			// gravity

	float _GradTensionCoef;		// Coefficient when calculating Tension
	float _LapTensionCoef;		// Coefficient when calculating Tension
	float3 _Range;				// Simulation space
	float _tensionThreshold;	//Tension Threshold
	float _tensionCoefficient;	//Tension Coefficient

    bool _oddStep;              // update postion depened on leap method  
    // float _slowDownFactor;

	float3 _MousePos;			// Mouse position
	float _MouseRadius;			// Radius of mouse interaction
	bool _MouseDown;			// Is the mouse pressed
};
// ▲ Definition of shader constants -----------------------



// ▼ ★ Main body from here --------------------------------------

/// Implementation of Poly6 Kernel 
/// W_poly6(r, h) = DensityCoef * (h^2 - r^2)^3
/// -> DensityCoef = ParticleMass * 4 / (PI * Smoothlen^8)
inline float CalculateDensity(float r_sq) {
	const float h_sq = _Smoothlen * _Smoothlen;
	return _DensityCoef * (h_sq - r_sq) * (h_sq - r_sq) * (h_sq - r_sq);
}

/// Becker2007 Implementation of uncompressed conditions:
/// Pressure = B * ((rho / rho_0)^gamma  - 1)
/// The pressure constant B should be calculated accurately, but it is not suitable for real time, so set it to an appropriate value.
inline float CalculatePressure(float density) {
	return _PressureStiffness * max(pow(abs(density / _RestDensity), 7) - 1, 0);
}

/// Implementation of Spiky kernel
/// mass * ((pressure_i + pressure_j)/(2 * density_j)) * Grad(W_Spiky)
/// Grad(W_Spiky) = -30 / (pi * h^5) * (h - r)^2
inline float3 CalculateGradPressure(float r, float P_pressure, float N_pressure, float N_density, float3 diff) {
	const float h = _Smoothlen;
	float avg_pressure = 0.5f * (N_pressure + P_pressure);
	// _GradPressureCoef = particleMass * -45.0f / (Mathf.PI * Mathf.Pow(smoothlen, 6))
	// N=j
	// P=i curr particle
	// float3 Grad=W_Spiky=_GradPressureCoef*(h - r) * (h - r) * diff / r;
	return _GradPressureCoef * avg_pressure / N_density * (h - r) * (h - r) / r * (diff);
}

/// Viscosity kernel implementation:
/// mass * (u_j - u_i) / density_j * Laplacian(W_viscosity)
/// Laplacian(W_viscosity) = 20 / (3 * pi * h^5) * (h - r)
inline float3 CalculateLapVelocity(float r, float3 P_velocity, float3 N_velocity, float N_density) {
	const float h = _Smoothlen;
	// _LapViscosityCoef= particleMass * 45f / (Mathf.PI * Mathf.Pow(smoothlen, 6))
	// N=j
	// P=i curr particle
	float3 vel_diff = (N_velocity - P_velocity);
	return _LapViscosityCoef / N_density * (h - r) * vel_diff;
}

inline ColorField CalculateSurfaceTension(float r_sq , float N_density, float3 diff)
{
	//diff =r=ri-rj
	//N=j is neighbors
	//p=i
	ColorField color;
	float colorField = 0.0f;
	float3 colorGradient = float3(0,0,0);
	float colorLaplacian = 0.0f;
	float tensionCoefficient = 0.0728f;
	const float h = _Smoothlen;
	const float h_sq = _Smoothlen * _Smoothlen;
	// const float r_sq = r * r;

	// colorField += j.mass / j.density * Kernel.Poly6(i.position - j.position, h);
	colorGradient=_GradTensionCoef*diff * (h_sq - r_sq) *(h_sq - r_sq) /N_density;
  
	// colorGradient += j.mass / j.density * Kernel.Poly6Grad(i.position - j.position, h);


	colorLaplacian=_LapTensionCoef * (h_sq - r_sq) *(3 *(pow(h ,3))-7*r_sq)/N_density;

	// colorLaplacian += j.mass / j.density * Kernel.Poly6Lap(i.position - j.position, h);



	float sqrMagnitude=colorGradient.x*colorGradient.x+colorGradient.y*colorGradient.y+colorGradient.z*colorGradient.z;
	if (sqrMagnitude < _tensionThreshold * _tensionThreshold)
	{
		// This particle isn't close to the surface
		return color;
	}

	color.colorField=colorField;
	color.colorLaplacian=colorLaplacian;
	color.colorGradient=colorGradient;
	// float tension=-tensionCoefficient*colorLaplacian*colorGradient/colorField

	return color;
}


// ▼ Kernel function

//--------------------------------------------------------------------------------------
// Density calculation
//--------------------------------------------------------------------------------------
[numthreads(THREAD_SIZE_X, 1, 1)]
void DensityCS(uint3 DTid : SV_DispatchThreadID) {
	uint P_ID = DTid.x;	// Particle ID currently being processed

	float h_sq = _Smoothlen * _Smoothlen;
	float3 P_position = _ParticlesBufferRead[P_ID].position;

	// TODO:convert To hash
	// Neighborhood search(O(n^2))
	float density = 0;
	for (uint N_ID = 0; N_ID < (uint)_NumParticles; N_ID++) {
		if (N_ID == P_ID) continue;	// Skip if self is the calculation target

		float3 N_position = _ParticlesBufferRead[N_ID].position;
		// N=j
		// P=i
		float3 diff = N_position - P_position;	// Particle distance
		float r_sq = dot(diff, diff);			// Particle distance squared

		// Exclude particles that do not fit within the radius
		if (r_sq < h_sq) {
			density += CalculateDensity(r_sq);	// No need to take the route
		}
	}

	// Update density buffer
	_ParticlesDensityBufferWrite[P_ID].density = density;
}


//--------------------------------------------------------------------------------------
// Pressure calculation ///  equation Tait
//--------------------------------------------------------------------------------------
[numthreads(THREAD_SIZE_X, 1, 1)]
void PressureCS(uint3 DTid : SV_DispatchThreadID) {
	uint P_ID = DTid.x;	// Particle ID currently being processed

	float  P_density = _ParticlesDensityBufferRead[P_ID].density;	// Density calculated earlier
	float  P_pressure = CalculatePressure(P_density);	// Pressure calculation

	// Update pressure buffer
	_ParticlesPressureBufferWrite[P_ID].pressure = P_pressure;
}


//--------------------------------------------------------------------------------------
// Calculation of force (acceleration)
//--------------------------------------------------------------------------------------
[numthreads(THREAD_SIZE_X, 1, 1)]
void ForceCS(uint3 DTid : SV_DispatchThreadID) {
	uint P_ID = DTid.x; // Particle ID currently being processed

	float3 P_position = _ParticlesBufferRead[P_ID].position;
	float3 P_velocity = _ParticlesBufferRead[P_ID].velocity;
	float  P_density = _ParticlesDensityBufferRead[P_ID].density;		// Density calculated earlier
	float  P_pressure = _ParticlesPressureBufferRead[P_ID].pressure;	// The pressure calculated earlier

	const float h_sq = _Smoothlen * _Smoothlen;
	//N=j
	//P=i
	// Neighborhood search(O(n^2))
	float3 press = float3(0, 0, 0);
	float3 visco = float3(0, 0, 0);
	// float3 surfaceTension = float3(0, 0, 0);
	ColorField temp;
	ColorField color;
	for (uint N_ID = 0; N_ID < (uint)_NumParticles; N_ID++) {
		if (N_ID == P_ID) continue;	// Skip if targeting yourself

		float3 N_position = _ParticlesBufferRead[N_ID].position;

		float3 diff = N_position - P_position;
		float r_sq = dot(diff, diff);

		// Exclude particles that do not fit within the radius
		if (r_sq < h_sq) {	
			float  N_density = _ParticlesDensityBufferRead[N_ID].density;
			float  N_pressure = _ParticlesPressureBufferRead[N_ID].pressure;
			float3 N_velocity = _ParticlesBufferRead[N_ID].velocity;
			float  r = sqrt(r_sq);

			// Pressure term
			press += CalculateGradPressure(r, P_pressure, N_pressure, N_density, diff);

			// sticky item
			visco += CalculateLapVelocity(r, P_velocity, N_velocity, N_density);

			temp=CalculateSurfaceTension(r_sq,N_density,diff);
			color.colorGradient+=temp.colorGradient;
			color.colorLaplacian+=temp.colorLaplacian;


		}
	}
	float3 colorGradient=color.colorGradient;
	float madntiude=sqrt(colorGradient.x*colorGradient.x + colorGradient.y*colorGradient.y + colorGradient.z*colorGradient.z);
	float3 tension=-_tensionCoefficient*color.colorLaplacian*color.colorGradient/madntiude;
	tension=float3(0,0,0);
	
	// Integration
	float3 force = press + _Viscosity * visco + tension;

	// Acceleration buffer update
	_ParticlesForceBufferWrite[P_ID].acceleration = force / P_density;
}


//--------------------------------------------------------------------------------------
// Update the position by performing collision detection etc.
//--------------------------------------------------------------------------------------
[numthreads(THREAD_SIZE_X, 1, 1)]
void IntegrateCS(uint3 DTid : SV_DispatchThreadID) {
	const unsigned int P_ID = DTid.x; // Particle ID currently being processed

	// Position and speed before update
	float3 position = _ParticlesBufferRead[P_ID].position;
	float3 velocity = _ParticlesBufferRead[P_ID].velocity;
	float3 acceleration = _ParticlesForceBufferRead[P_ID].acceleration;	// Calculated acceleration
	float3 oldacceleration=_ParticlesForceOldBufferRead[P_ID].acceleration;
	// Here to write collision detection -----

	// Wall boundary (penalty method)
	float dist;
	//x in 0
	dist = dot(float4(position, 1), float4(1, 0, 0, 0));
	acceleration += min(dist, 0) * -_WallStiffness * float3(1, 0, 0);
	//y in 0
	dist = dot(float4(position, 1), float4(0, 1, 0, 0));
	acceleration += min(dist, 0) * -_WallStiffness * float3(0, 1, 0);
	//z in 0
	dist = dot(float4(position, 1), float4(0, 0, 1, 0));
	acceleration += min(dist, 0) * -_WallStiffness * float3(0, 0, 1);
	//x in max
	dist = dot(float4(position, 1), float4(-1, 0, 0, _Range.x));
	acceleration += min(dist, 0) * -_WallStiffness * float3(-1, 0, 0);
	//y in max
	dist = dot(float4(position, 1), float4(0, -1, 0, _Range.y));
	acceleration += min(dist, 0) * -_WallStiffness * float3(0, -1, 0);
	//z in max
	dist = dot(float4(position, 1), float4(0, 0, -1, _Range.z));
	acceleration += min(dist, 0) * -_WallStiffness * float3(0, 0, -1);

	// Gravity addition
	//TODO:must _Gravity*_mass
	acceleration += _Gravity;

	// Update the next particle position with the forward Euler method
	// velocity += _TimeStep * acceleration;
	// position += _TimeStep * velocity;
    
    
    _ParticlesForceOldBufferWrite[P_ID].acceleration=acceleration;

    // Update the next particle with the leapForg method

    if (_oddStep){
        //update velocity
        velocity += 0.5f*(oldacceleration + acceleration)*_TimeStep;
    }else{
        //update position
        position += velocity*_TimeStep+0.5f*acceleration*_TimeStep*_TimeStep;
    }

    // Particle buffer update
	_ParticlesBufferWrite[P_ID].position = position;
	_ParticlesBufferWrite[P_ID].velocity = velocity;

   

}


